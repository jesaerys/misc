"""
The original idea for the `Param` class was to have values that could
readily be written to parameter files by having the values carry around
their own individualized format strings. Ultimately, I've decided it's
better to use dedicated formatter classes and functions and to the actual
value types simple (integers, floats, and strings).

Writing this code was a good exercise in flexible input and type-checking
vs. duck typing (especially distinguishing between lists, strings, lists of
strings, lists of lists, etc.), as well as class properties, so I've
decided to save it.

"""
class Param(object):

    """Class that bundles a format string with a value.

    Attaching a format string to a value eliminates the need for
    independently keeping track of the value's intended format. Also, a
    formatted string for a `Param` instance is generated by any function
    that uses the `__str__` method, such as `print` or `str()`.

    Parameters
    ----------
    val : None, bool, str, int, float, list, or tuple
        Initialize the `val` property.
    fmt : str, optional
        Initialize the `fmt` property. Default is None (or None for each
        value in `val`). If `val` is multivalued and `fmt` is not, then
        automatically apply `fmt` to each value.
    delim : str, optional
        Initialize the `delim` attribute. Default is a single comma without
        spaces, ",".

    Attributes
    ----------
    delim : str
        The delimiter to use when formatting `val` as a string if `val` is
        list-like.

    Methods
    -------
    val
        Property (get and set). The value or set of values.
    fmt
        Property (get and set). Format string for the `val` property. If
        `val` is a list, then `fmt` is a list with a format string for each
        value in `val` (this is checked whenever `val` is updated; `fmt`
        will automatically be expanded to a list of the correct length if
        `val` is updated with a single format string). `fmt` should either
        use an index of 0 or no index at all (e.g., '{0:d}' or '{:d}').

    Examples
    --------
    There are several ways to initialize `Param`. For example,

    >>> def print_param(p):
    ...    print p.val, p.fmt, p

    Single value, no format:

    >>> p = Param(0)
    >>> x = 3.14159
    >>> p.val = x  # `.val` can be updated whenever
    >>> print_param(p)
    3.14159 None 3.14159
    >>> p.fmt = '{:.2f}'  # now assign a format
    >>> print_param(p)
    3.14159 {:.2f} 3.14

    The last result can also be achieved by specifying a format right at
    initialization, either with the `fmt` keyword or by pairing the value
    with the format string in a tuple:

    >>> str(p) == str(Param(x, fmt='{:.2f}')) == str(Param((x, '{:.2f}')))
    True

    Multiple values, no formats (can optionally set the delimiter at
    initialization, or later with the `.delim` attribute):

    >>> print_param(Param((3.14159, 6.28319), delim='; '))
    [3.14159, 6.28319] [None, None] 3.14159; 6.28319

    Multiple values with formats:

    >>> x_list, fmt_list = (3.14159, 6.28319), ('{:.2f}', '{:.3f}')
    >>> print_param(Param(x_list, fmt=fmt_list))
    [3.14159, 6.28319] ('{:.2f}', '{:.3f}') 3.14,6.283
    >>> print_param(Param(zip(x_list, fmt_list)))  # same result
    [3.14159, 6.28319] ('{:.2f}', '{:.3f}') 3.14,6.283

    Not all values require formats:

    >>> p.fmt
    '{:.2f}'
    >>> p.val = [x, (2*x, '{:.1f}')]  # Only format the 2nd number
    >>> p.fmt  # `.fmt` is automatically updated with `.val`!
    [None, '{:.1f}']
    >>> p.delim = ' , '
    >>> str(p)
    '3.14159 , 6.3'

    Values and formats can be indexed. Assignment for indexed values breaks
    automatic format updating, however. Also, an indexed value *should not*
    be assigned a value-format pair!

    >>> p.val[1] = 1
    >>> print_param(p)  # `.fmt` is not automatically updated in this case!
    [3.14159, 1] [None, '{:.1f}'] 3.14159 , 1.0
    >>> p.fmt[1] = '{:d}'  # `.fmt` must be updated manually
    >>> str(p)
    '3.14159 , 1'
    >>> p.val[1] = (x, '{:.2f}')  # Don't do this!!!
    >>> str(p)
    ValueError ...

    """

    def __init__(self, val, fmt=None, delim=None):
        fmt0 = fmt
        val_list, fmt_list = get_vals_fmts(val)
        if not val_list:
            val, fmt = None, None
        elif len(val_list) == 1:
            val, fmt = val_list[0], fmt_list[0]
        else:
            val, fmt = val_list, fmt_list
        fmt = fmt if fmt0 is None else fmt0

        self._val = val
        self.fmt = fmt

        if delim is None:
            delim = ','
        self.delim = delim

    def __str__(self):
        if not islistlike(self._val):
            val_list, fmt_list = [self._val], [self._fmt]
        else:
            val_list, fmt_list = self._val, self._fmt

        valstr_list = [str(val) if fmt is None else fmt.format(val)
                       for val, fmt in zip(val_list, fmt_list)]

        return self.delim.join(valstr_list)

    def __repr__(self):
        return str(self.val)

    @property
    def val(self):
        return self._val

    @val.setter
    def val(self, val):
        val_list, fmt_list = get_vals_fmts(val)
        if not val_list:
            val, fmt = None, None
        elif len(val_list) == 1:
            val, fmt = val_list[0], fmt_list[0]
        else:
            val, fmt = val_list, fmt_list
        self._val = val
        self._fmt = fmt

    @property
    def fmt(self):
        return self._fmt

    @fmt.setter
    def fmt(self, fmt):
        if not islistlike(fmt) and islistlike(self._val):
            fmt = [fmt] * len(self._val)
        self._fmt = fmt


def isstring(obj):
    """True if the object is a string."""
    return isinstance(obj, basestring)


def isfmtstr(obj):
    """True if obj looks like a format string."""
    return (isstring(obj) and obj.startswith('{') and obj.endswith('}')
            and ':' in obj)


def islistlike(obj):
    """True if the object is iterable like a list and is *not* a string."""
    return ((hasattr(obj, '__iter__') or hasattr(obj, '__getitem__')) and
            not isstring(obj))


def get_vals_fmts(val):
    """Given a given value, identify the form and return a list of values
    and format strings.

    Parameters
    ----------
    val : None, bool, int, float, str, list, or tuple
        Valid forms of `val` are,

        - x
        - (x, fmt)
        - (x1, x2, ...)
        - [(x1, fmt1), (x2, fmt2), ...]

        where `x` is None, bool, int, float, or str. `fmt` is a format
        string (starts with '{', ends with '}', and contains ':').

    Returns
    -------
    val_list, fmt_list : list
        For the four cases above, the returned lists are,

        - [x], [None]
        - [x], [fmt]
        - [x1, x2, ...], [None, None, ...]
        - [x1, x2, ...], [fmt1, fmt2, ...]

        `val_list` is never empty, and `fmt_list` is always the same length
        as `val_list`.

    """
    val_list, fmt_list = [], []
    val0 = val
    while val0:
        if islistlike(val0):
            if len(val0) == 2 and isfmtstr(val0[1]):  # (val, fmt)
                val, fmt = val0
                val_list.append(val)
                fmt_list.append(fmt)
                break

            else:  # (..., val_i, ...) or [..., (val_i, fmt_i), ...]
                val = val0[0]
                if islistlike(val):  # (val_i, fmt_i)
                    val, fmt = val
                    val_list.append(val)
                    fmt_list.append(fmt)
                else:  # val_i; no format
                    val_list.append(val)
                    fmt_list.append(None)

                if len(val0) == 1:
                    break
                else:
                    val0 = val0[1:]

        else:  # val; no format
            val_list.append(val0)
            fmt_list.append(None)
            break

    else:
        if val0 in [None, False]:
            val_list.append(val0)
            fmt_list.append(None)

    return val_list, fmt_list
